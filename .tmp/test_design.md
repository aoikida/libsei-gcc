# テスト設計書 - libsei Ubuntu 22.04 移植プロジェクト

## 1. テスト概要

### 1.1 テスト目的

- libseiライブラリのUbuntu 22.04環境（glibc 2.35 + GCC 11.4）での正常動作確認
- 移植に伴う機能回帰の防止
- トランザクショナルメモリ機能の互換性検証
- パフォーマンス要件の達成確認

### 1.2 テスト範囲

- **対象**: 
  - 全公開API (`__begin`, `__end`, `__output_*`系マクロ)
  - TMI (Transactional Memory Interface)
  - 実行モード (COW, Heap, Instrumentation)
  - メモリ管理システム
  - 互換性レイヤー (support.c)
  - ビルドシステム
- **対象外**: 
  - 非対応アーキテクチャ (ARM等)
  - 実験的機能の将来変更
  - 外部ライブラリ (libitm) の内部動作

### 1.3 テスト環境

- **基本環境**: Ubuntu 22.04.5 LTS
- **コンパイラ**: GCC 11.4.0
- **依存関係**: glibc 2.35, libitm
- **比較環境**: Ubuntu 14.04 (eglibc 2.19, GCC 4.7) でのビルド確認

## 2. テストケース設計

### 2.1 ビルドシステムのテストケース

#### 2.1.1 正常系テスト

| ID   | テストケース名 | 入力データ | 期待結果 | 優先度 |
|------|----------------|------------|----------|---------|
| B001 | 基本ビルド成功 | `make clean && make` | エラーなし、libsei.a生成 | High |
| B002 | デバッグビルド | `make clean && make DEBUG=1` | デバッグ情報付きビルド成功 | High |
| B003 | テストビルド | `make clean && make test` | 全テスト実行ファイル生成 | High |
| B004 | サンプルビルド | `cd examples/simple && make` | simple実行ファイル生成 | High |
| B005 | UKVサンプル | `cd examples/ukv && make` | ukv関連実行ファイル生成 | Medium |

#### 2.1.2 異常系テスト

| ID   | テストケース名 | 入力データ | 期待結果 | 優先度 |
|------|----------------|------------|----------|---------|
| B101 | TM無効環境 | `-fgnu-tm`フラグなし | 適切なエラーメッセージ | Medium |
| B102 | 依存関係不足 | libitm不在環境 | リンクエラーと説明 | Medium |

#### 2.1.3 境界値テスト

| ID   | テストケース名 | 入力データ | 期待結果 | 優先度 |
|------|----------------|------------|----------|---------|
| B201 | 最大デバッグレベル | `make DEBUG=3` | 詳細ログ付きビルド成功 | Low |
| B202 | 最適化ビルド | `make CFLAGS="-O3"` | 最適化ビルド成功 | Low |

### 2.2 互換性レイヤーのテストケース

#### 2.2.1 正常系テスト - glibc関数競合解決

| ID   | テストケース名 | 入力データ | 期待結果 | 優先度 |
|------|----------------|------------|----------|---------|
| C001 | strtol系関数 | 文字列→数値変換 | 正常な変換動作 | High |
| C002 | realloc関数 | メモリ再配置 | 正常なメモリ管理 | High |
| C003 | memmove関数 | メモリ移動操作 | データ正常移動 | High |
| C004 | strdup系関数 | 文字列複製 | 正常な複製動作 | High |

#### 2.2.2 異常系テスト

| ID   | テストケース名 | 入力データ | 期待結果 | 優先度 |
|------|----------------|------------|----------|---------|
| C101 | 不正な文字列変換 | 非数値文字列 | エラー処理とerrno設定 | Medium |
| C102 | 不正realloc | NULLポインタ | 適切なエラー処理 | Medium |

### 2.3 Transactional Memory機能のテストケース

#### 2.3.1 正常系テスト - 基本TM機能

| ID   | テストケース名 | 入力データ | 期待結果 | 優先度 |
|------|----------------|------------|----------|---------|
| T001 | 基本トランザクション | `__begin` → 処理 → `__end` | 正常なトランザクション完了 | High |
| T002 | 冗長実行 | 状態変更を伴う処理 | 両回の実行で同一結果 | High |
| T003 | 入力検証 | 正常なCRC付きメッセージ | トランザクション開始成功 | High |
| T004 | 出力生成 | `__output_append` → `__output_done` | 正常なCRC生成 | High |

#### 2.3.2 異常系テスト - TM異常処理

| ID   | テストケース名 | 入力データ | 期待結果 | 優先度 |
|------|----------------|------------|----------|---------|
| T101 | CRC不一致 | 不正なCRCのメッセージ | `__begin`でfalse返却 | High |
| T102 | メモリ不足 | 大量メモリ確保 | 適切なabort処理 | Medium |
| T103 | 不正サイズ | サイズ0のメッセージ | エラー処理 | Medium |

#### 2.3.3 境界値テスト

| ID   | テストケース名 | 入力データ | 期待結果 | 優先度 |
|------|----------------|------------|----------|---------|
| T201 | 最大メッセージサイズ | 大容量メッセージ | 正常処理またはエラー | Medium |
| T202 | 最小メッセージサイズ | 1byteメッセージ | 正常処理 | Medium |

### 2.4 実行モードのテストケース

#### 2.4.1 COW Mode (`MODE=cow`)

| ID   | テストケース名 | 入力データ | 期待結果 | 優先度 |
|------|----------------|------------|----------|---------|
| M001 | COW基本動作 | 読み書き操作 | Copy-on-Write動作 | High |
| M002 | COW最適化 | 読み取り専用操作 | コピー未発生 | Medium |

#### 2.4.2 Heap Mode (`MODE=heap`)

| ID   | テストケース名 | 入力データ | 期待結果 | 優先度 |
|------|----------------|------------|----------|---------|
| M011 | ヒープ基本動作 | デュアルヒープ操作 | 正常なヒープ切り替え | High |

#### 2.4.3 Instrumentation Mode (`MODE=instr`)

| ID   | テストケース名 | 入力データ | 期待結果 | 優先度 |
|------|----------------|------------|----------|---------|
| M021 | 計装モード | インストルメンテーション | ログ記録のみ | Low |

### 2.5 統合テストシナリオ

#### シナリオ1: 基本的なメッセージ処理

1. **前提条件**: libseiライブラリが正常にビルドされている
2. **テスト手順**:
   - Step 1: 入力メッセージとCRCを準備
   - Step 2: `__begin(msg, size, crc)` で開始
   - Step 3: メッセージ処理（状態変更含む）
   - Step 4: `__output_append(output, len)` で出力追加
   - Step 5: `__output_done()` で出力完了
   - Step 6: `__end()` でトランザクション終了
   - Step 7: `__crc_pop()` でCRC取得
3. **期待結果**: 全ステップが成功し、正しいCRCが生成される

#### シナリオ2: エラー回復処理

1. **前提条件**: 不正なCRCを持つ入力メッセージ
2. **テスト手順**:
   - Step 1: 不正CRCのメッセージを準備
   - Step 2: `__begin(msg, size, wrong_crc)` で開始試行
   - Step 3: 戻り値の確認
   - Step 4: 後続処理のスキップ確認
3. **期待結果**: `__begin`がfalseを返し、トランザクションが開始されない

#### シナリオ3: 高負荷処理

1. **前提条件**: 大量の連続トランザクション
2. **テスト手順**:
   - Step 1: 1000回の連続トランザクション実行
   - Step 2: メモリ使用量の監視
   - Step 3: パフォーマンス測定
3. **期待結果**: メモリリークなし、性能要件達成

## 3. テストデータ設計

### 3.1 マスタデータ

```json
{
  "testData": {
    "valid": {
      "simpleMessage": {
        "data": "Hello, World!",
        "size": 13,
        "crc": "0x12345678"
      },
      "largeMessage": {
        "data": "A".repeat(1024),
        "size": 1024,
        "crc": "0xABCDEF01"
      }
    },
    "invalid": {
      "wrongCrc": {
        "data": "Hello, World!",
        "size": 13,
        "crc": "0x00000000"
      },
      "nullData": {
        "data": null,
        "size": 0,
        "crc": "0x00000000"
      }
    },
    "boundary": {
      "minMessage": {
        "data": "A",
        "size": 1,
        "crc": "0x12345678"
      },
      "maxMessage": {
        "data": "A".repeat(65536),
        "size": 65536,
        "crc": "0xFFFFFFFF"
      }
    }
  }
}
```

### 3.2 モックデータ

- **システムコールモック**: malloc/free失敗シミュレーション
- **TMエラーモック**: トランザクション abort シミュレーション
- **CRCエラーモック**: チェックサム不整合シミュレーション

## 4. パフォーマンステスト

### 4.1 負荷テスト

- **同時トランザクション数**: 100
- **メッセージ処理レート**: 1000 msg/sec
- **期待レスポンスタイム**: 1ms以下（平均）
- **メモリ使用量**: 元実装の110%以下

### 4.2 ストレステスト

- **最大負荷条件**: 24時間連続実行
- **期待される挙動**: メモリリークなし、性能劣化なし

### 4.3 回帰テスト

- **ベンチマーク**: Ubuntu 14.04での元実装との比較
- **性能基準**: レイテンシ±10%、スループット±5%

## 5. セキュリティテスト

### 5.1 入力検証テスト

- **CRC検証**: 不正なチェックサム検出
- **バッファオーバーフロー**: 境界値でのメモリ安全性
- **ポインタ検証**: NULL、不正ポインタの処理

### 5.2 メモリ安全性テスト

- **Use-after-free**: 解放済みメモリアクセス検出
- **Double-free**: 重複解放の検出
- **Memory leak**: メモリリーク検出

## 6. テスト実行計画

### 6.1 実行順序

1. **フェーズ1: ビルドテスト**
   - 基本ビルド成功確認
   - 依存関係テスト
   - 各種設定でのビルド

2. **フェーズ2: 単体テスト**
   - 各コンポーネントの個別テスト
   - 互換性レイヤーテスト
   - API基本機能テスト

3. **フェーズ3: 統合テスト**
   - コンポーネント間連携テスト
   - エンドツーエンドシナリオ
   - エラー処理フローテスト

4. **フェーズ4: 性能・安定性テスト**
   - パフォーマンステスト
   - 長時間安定性テスト
   - メモリリークテスト

### 6.2 合格基準

- **機能テスト**: 全テストケースの100%合格
- **カバレッジ**: コードカバレッジ80%以上
- **パフォーマンス**: 元実装の±10%以内
- **ビルド**: 警告数の大幅削減（50%以下）

### 6.3 テスト実行コマンド

```bash
# 基本ビルドテスト
make clean && make 2>&1 | tee build.log

# 単体テスト実行
make test && find build -name "*.test" -exec {} \;

# サンプルテスト
cd examples/simple && make && ./simple

# パフォーマンステスト
cd tests && ./benchmark.sh

# メモリリークテスト
valgrind --leak-check=full ./examples/simple/simple
```

## 7. リスクと対策

| リスク | 影響度 | 発生確率 | 対策 |
|--------|--------|----------|------|
| GCC TM非互換性 | High | Medium | 段階的テスト、フォールバック実装準備 |
| glibc関数競合 | High | High | 詳細な単体テスト、条件付きコンパイル |
| 性能劣化 | Medium | Medium | ベンチマーク、プロファイリング |
| アセンブリ問題 | Medium | Low | C実装フォールバック、段階的検証 |
| メモリリーク | High | Low | Valgrind、継続的監視 |

## 8. テスト自動化戦略

### 8.1 自動化対象

- **ビルドテスト**: 全ビルド設定での自動ビルド
- **回帰テスト**: 既存テストスイートの自動実行
- **互換性テスト**: 複数環境での自動テスト
- **パフォーマンス監視**: 継続的な性能測定

### 8.2 CI/CD統合

```yaml
# .github/workflows/test.yml 例
name: libsei Test Suite
on: [push, pull_request]
jobs:
  build-test:
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@v4
      - name: Install dependencies
        run: sudo apt-get update && sudo apt-get install -y gcc libc6-dev
      - name: Build libsei
        run: cd libsei && make clean && make
      - name: Run tests
        run: cd libsei && make test
      - name: Run examples
        run: cd libsei/examples/simple && make && ./simple
```

### 8.3 テスト報告

- **自動レポート**: テスト結果の自動集計
- **トレンド分析**: 性能変化の継続的監視
- **品質ゲート**: 基準未達時の自動失敗
- **通知システム**: 重要な問題の即座な通知

## 9. 特殊テストケース

### 9.1 Ubuntu環境比較テスト

- **14.04 vs 22.04**: 同一コードの動作比較
- **eglibc vs glibc**: ライブラリ差異の影響確認
- **GCC 4.7 vs 11.4**: コンパイラ差異の検証

### 9.2 エッジケーステスト

- **極端な負荷**: システム限界での動作確認
- **リソース制限**: メモリ/CPU制限下での動作
- **エラー連鎖**: 複数エラーの同時発生

### 9.3 後方互換性テスト

- **API完全互換**: 既存アプリケーションの無変更動作
- **設定ファイル**: 既存設定での正常動作
- **データ形式**: 既存データの正常処理